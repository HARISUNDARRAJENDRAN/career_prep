/**
 * Agent Plans Tables
 *
 * Stores active plans and their steps for autonomous agents.
 * Plans are generated by the reasoning layer and executed by agents.
 *
 * @see docs/agentic-improvements/02-REASONING_LAYER_INTEGRATION.md
 */

import {
  pgTable,
  varchar,
  text,
  timestamp,
  jsonb,
  integer,
  real,
  boolean,
  pgEnum,
  index,
} from 'drizzle-orm/pg-core';
import { users } from './user';

// ============================================================================
// Enums
// ============================================================================

/**
 * Plan status enum
 */
export const planStatusEnum = pgEnum('plan_status', [
  'draft', // Plan generated but not yet started
  'active', // Currently executing
  'paused', // Temporarily paused
  'completed', // All steps completed successfully
  'failed', // Plan failed (after retries exhausted)
  'cancelled', // Manually cancelled
  'superseded', // Replaced by a new plan (adaptation)
]);

/**
 * Plan step status enum
 */
export const planStepStatusEnum = pgEnum('plan_step_status', [
  'pending', // Not yet started
  'executing', // Currently running
  'completed', // Finished successfully
  'failed', // Failed (may be retried)
  'skipped', // Skipped due to condition not met
  'waiting', // Waiting for external input or dependency
]);

/**
 * Agent name enum for plan ownership
 */
export const planAgentNameEnum = pgEnum('plan_agent_name', [
  'interviewer',
  'sentinel',
  'architect',
  'action',
  'strategist',
  'coordinator',
  'planner',
  'resume-architect',
]);

// ============================================================================
// Agent Plans Table
// ============================================================================

/**
 * Agent Plans Table
 *
 * Stores execution plans generated by the reasoning layer.
 * Each plan has a goal, constraints, and a sequence of steps.
 */
export const agentPlans = pgTable(
  'agent_plans',
  {
    id: varchar('id', { length: 36 })
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),

    // Ownership and scoping
    agent_name: planAgentNameEnum('agent_name').notNull(),
    user_id: varchar('user_id', { length: 255 }).references(
      () => users.clerk_id,
      { onDelete: 'cascade' }
    ),
    task_id: varchar('task_id', { length: 36 }), // Trigger.dev run ID

    // Goal this plan addresses
    goal_id: varchar('goal_id', { length: 36 }), // Reference to decomposed goal
    goal_description: text('goal_description').notNull(),

    // Plan status
    status: planStatusEnum('status').default('draft').notNull(),

    // Plan configuration
    config: jsonb('config')
      .notNull()
      .$type<{
        max_iterations: number;
        confidence_threshold: number;
        timeout_ms: number;
        allow_adaptation: boolean;
        tools_allowed?: string[];
        tools_excluded?: string[];
      }>(),

    // Execution tracking
    current_step_index: integer('current_step_index').default(0),
    total_steps: integer('total_steps').notNull(),
    iteration_count: integer('iteration_count').default(0),

    // Quality metrics
    estimated_duration_ms: integer('estimated_duration_ms'),
    actual_duration_ms: integer('actual_duration_ms'),
    confidence_score: real('confidence_score'), // Final confidence after execution

    // Adaptation tracking
    parent_plan_id: varchar('parent_plan_id', { length: 36 }), // Plan this was adapted from
    adaptation_reason: text('adaptation_reason'),

    // Result summary
    result: jsonb('result').$type<{
      success: boolean;
      output?: Record<string, unknown>;
      error?: string;
      metrics?: Record<string, number>;
    }>(),

    // Metadata for debugging
    metadata: jsonb('metadata').$type<{
      reasoning_trace?: string[];
      tools_considered?: string[];
      context_snapshot?: Record<string, unknown>;
    }>(),

    // Timestamps
    created_at: timestamp('created_at').defaultNow().notNull(),
    started_at: timestamp('started_at'),
    completed_at: timestamp('completed_at'),
    updated_at: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => [
    // Fast lookup by agent + status
    index('idx_agent_plans_agent_status').on(table.agent_name, table.status),

    // Fast lookup by user
    index('idx_agent_plans_user').on(table.user_id),

    // Fast lookup by task
    index('idx_agent_plans_task').on(table.task_id),

    // Find active plans
    index('idx_agent_plans_active').on(table.status),

    // Find adapted plans
    index('idx_agent_plans_parent').on(table.parent_plan_id),
  ]
);

// ============================================================================
// Agent Plan Steps Table
// ============================================================================

/**
 * Agent Plan Steps Table
 *
 * Individual steps within a plan.
 * Each step has a tool, inputs, expected outputs, and execution state.
 */
export const agentPlanSteps = pgTable(
  'agent_plan_steps',
  {
    id: varchar('id', { length: 36 })
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),

    // Parent plan reference
    plan_id: varchar('plan_id', { length: 36 })
      .notNull()
      .references(() => agentPlans.id, { onDelete: 'cascade' }),

    // Step identification
    step_index: integer('step_index').notNull(), // Order in plan (0-indexed)
    step_name: varchar('step_name', { length: 100 }).notNull(),
    description: text('description'),

    // Tool to execute
    tool_id: varchar('tool_id', { length: 100 }).notNull(),
    tool_input: jsonb('tool_input').$type<Record<string, unknown>>(),

    // Expected output schema (for validation)
    expected_output_description: text('expected_output_description'),

    // Status and execution
    status: planStepStatusEnum('status').default('pending').notNull(),
    retry_count: integer('retry_count').default(0),
    max_retries: integer('max_retries').default(3),

    // Dependencies
    depends_on: jsonb('depends_on').$type<string[]>(), // Step IDs that must complete first

    // Conditional execution
    condition: jsonb('condition').$type<{
      type: 'always' | 'if_output' | 'if_confidence' | 'if_error';
      step_id?: string;
      output_key?: string;
      operator?: 'eq' | 'gt' | 'lt' | 'contains' | 'exists' | 'not_exists';
      value?: unknown;
    }>(),

    // Fallback on failure
    fallback_step_index: integer('fallback_step_index'),

    // Execution result
    output: jsonb('output').$type<Record<string, unknown>>(),
    error: text('error'),
    duration_ms: integer('duration_ms'),

    // Quality assessment
    confidence_score: real('confidence_score'), // How confident we are in the output

    // Timestamps
    started_at: timestamp('started_at'),
    completed_at: timestamp('completed_at'),
    created_at: timestamp('created_at').defaultNow().notNull(),
  },
  (table) => [
    // Fast lookup by plan + order
    index('idx_plan_steps_plan_order').on(table.plan_id, table.step_index),

    // Find steps by status
    index('idx_plan_steps_status').on(table.status),

    // Find steps by tool (for analytics)
    index('idx_plan_steps_tool').on(table.tool_id),
  ]
);

// ============================================================================
// Agent Goals Table (Decomposed Goals)
// ============================================================================

/**
 * Agent Goals Table
 *
 * Stores goals and sub-goals created by the goal decomposer.
 * Hierarchical structure for complex goal breakdown.
 */
export const agentGoals = pgTable(
  'agent_goals',
  {
    id: varchar('id', { length: 36 })
      .primaryKey()
      .$defaultFn(() => crypto.randomUUID()),

    // Ownership
    agent_name: planAgentNameEnum('agent_name').notNull(),
    user_id: varchar('user_id', { length: 255 }).references(
      () => users.clerk_id,
      { onDelete: 'cascade' }
    ),
    task_id: varchar('task_id', { length: 36 }),

    // Hierarchy
    parent_goal_id: varchar('parent_goal_id', { length: 36 }), // Null = root goal
    depth: integer('depth').default(0).notNull(), // 0 = root, 1 = sub-goal, etc.

    // Goal content
    description: text('description').notNull(),
    success_criteria: jsonb('success_criteria').$type<string[]>(),
    priority: varchar('priority', { length: 20 }).default('medium'), // 'high', 'medium', 'low'

    // Estimation
    estimated_steps: integer('estimated_steps'),
    estimated_duration_ms: integer('estimated_duration_ms'),

    // Status
    status: varchar('status', { length: 20 }).default('pending'), // 'pending', 'in_progress', 'achieved', 'failed', 'abandoned'
    achieved_at: timestamp('achieved_at'),

    // Result
    result: jsonb('result').$type<{
      achieved: boolean;
      output?: Record<string, unknown>;
      criteria_met?: string[];
      criteria_failed?: string[];
    }>(),

    // Timestamps
    created_at: timestamp('created_at').defaultNow().notNull(),
    updated_at: timestamp('updated_at').defaultNow().notNull(),
  },
  (table) => [
    // Fast lookup by parent (for hierarchy traversal)
    index('idx_agent_goals_parent').on(table.parent_goal_id),

    // Fast lookup by agent + user
    index('idx_agent_goals_agent_user').on(table.agent_name, table.user_id),

    // Fast lookup by task
    index('idx_agent_goals_task').on(table.task_id),

    // Find active goals
    index('idx_agent_goals_status').on(table.status),
  ]
);

// ============================================================================
// Type Exports
// ============================================================================

export type AgentPlan = typeof agentPlans.$inferSelect;
export type NewAgentPlan = typeof agentPlans.$inferInsert;

export type AgentPlanStep = typeof agentPlanSteps.$inferSelect;
export type NewAgentPlanStep = typeof agentPlanSteps.$inferInsert;

export type AgentGoal = typeof agentGoals.$inferSelect;
export type NewAgentGoal = typeof agentGoals.$inferInsert;

export type PlanStatus = (typeof planStatusEnum.enumValues)[number];
export type PlanStepStatus = (typeof planStepStatusEnum.enumValues)[number];
export type PlanAgentName = (typeof planAgentNameEnum.enumValues)[number];
